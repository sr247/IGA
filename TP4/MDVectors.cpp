
/* ############################################################################################################################
   #
   # MDVectors.cpp: Vector operations
   #
   ############################################################################################################################ */

#include <math.h>
#include <memory.h>
/* *** */
#include "MDVectors.h"

 
/* ############################################################################################################################ */

/* ############################################################################################################################
   # Fonction de calcul de la transposée
   ############################################################################################################################ */

_GLOBAL_ void MDTransposef(MDFloat *M)
{
/* **************************************************************************************************************************** */
	int		 i, j; 
	MDFloat	 temp;
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=j; i<4; i++) {
			temp	 = A[i][j];
			A[i][j]	 = A[j][i];
			A[j][i]	 = temp;
		}
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de calcul de la matrice de transalation
   ############################################################################################################################ */

_GLOBAL_ void MDTranslatef(MDFloat *M, MDFloat dx, MDFloat dy, MDFloat dz)
{
/* **************************************************************************************************************************** */
	int	i, j; 
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=0; i<4; i++)
			if (i == j)
				A[i][j]	 = 1.0;
			else
				A[i][j]	 = 0.0;
/* **************************************************************************************************************************** */
	A[0][3]	 = dx;
	A[1][3]	 = dy;
	A[2][3]	 = dz;
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de calcul de la matrice de rotation suivant l'axe oX
   ############################################################################################################################ */

_GLOBAL_ void MDRotatexf(MDFloat *M, MDFloat alpha)
{
/* **************************************************************************************************************************** */
	int		 i, j;
	double	 a	 = _PI_*alpha/180;
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=0; i<4; i++)
			if (i == j)
				A[i][j]	 = 1.0;
			else
				A[i][j]	 = 0.0;
/* **************************************************************************************************************************** */
	A[1][1]	 = (MDFloat)  cos(a);
	A[2][1]	 = (MDFloat)  sin(a);
	A[1][2]	 = (MDFloat) -sin(a);
	A[2][2]	 = (MDFloat)  cos(a);
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de calcul de la matrice de rotation suivant l'axe oY
   ############################################################################################################################ */

_GLOBAL_ void MDRotateyf(MDFloat *M, MDFloat alpha)
{
/* **************************************************************************************************************************** */
	int		 i, j;
	double	 a	 = _PI_*alpha/180;
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=0; i<4; i++)
			if (i == j)
				A[i][j]	 = 1.0;
			else
				A[i][j]	 = 0.0;
/* **************************************************************************************************************************** */
	A[0][0]	 = (MDFloat)  cos(a);
	A[2][0]	 = (MDFloat) -sin(a);
	A[0][2]	 = (MDFloat)  sin(a);
	A[2][2]	 = (MDFloat)  cos(a);
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de calcul de la matrice de rotation suivant l'axe oZ 
   ############################################################################################################################ */

_GLOBAL_ void MDRotatezf(MDFloat *M, MDFloat alpha)
{
/* **************************************************************************************************************************** */
	int		 i, j;
	double	 a	 = _PI_*alpha/180;
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=0; i<4; i++)
			if (i == j)
				A[i][j]	 = 1.0;
			else
				A[i][j]	 = 0.0;
/* **************************************************************************************************************************** */
	A[0][0]	 = (MDFloat)  cos(a);
	A[1][0]	 = (MDFloat)  sin(a);
	A[0][1]	 = (MDFloat) -sin(a);
	A[1][1]	 = (MDFloat)  cos(a);
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de multiplication de matrices
   ############################################################################################################################ */

_GLOBAL_ void MultMatrix4x4(MDFloat (*A)[4], MDFloat (*B)[4], MDFloat (*res)[4]) {
/* **************************************************************************************************************************** */
	MDInt	 i, j, k;
/* **************************************************************************************************************************** */
	for (i=0; i<4; i++) {
		for (j=0; j<4; j++) {
			res[i][j]	 = 0.0;
			for (k=0; k<4; k++) {
				res[i][j]	+= A[k][j]*B[i][k];
			}
		}
	}
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de multiplication d'un vecteur par une matrice
   ############################################################################################################################ */

_GLOBAL_ void MultVecMatrix4(MDFloat v[4], MDFloat(*A)[4], MDFloat res[4]) {
/* **************************************************************************************************************************** */
	int	 i,j;
/* **************************************************************************************************************************** */
	for (i=0; i<4; i++) {
		res[i]	 = 0.0;
		for (j=0; j<4; j++) {
			res[i]	+= A[i][j]*v[j];
		}
	}
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction du produit sclaire de deux vecteurs
   ############################################################################################################################ */

_GLOBAL_ void VectProd(MDFloat *u, MDFloat *v, MDFloat *w) {
/******************************************************************************************************************************/
	w[0] = u[1]*v[2] - u[2]*v[1];
	w[1] = u[2]*v[0] - u[0]*v[2];
	w[2] = u[0]*v[1] - u[1]*v[0];
	w[3] = 1;
/******************************************************************************************************************************/
}

/* ############################################################################################################################
   # Fonction de copie d'une matrice
   ############################################################################################################################ */

_GLOBAL_ void CopyMatrix4x4(MDFloat *Src, MDFloat *Dst) {
/* **************************************************************************************************************************** */
	memcpy(Dst, Src, 4*4*sizeof(MDFloat));
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction d'initialisation d'une matrice à la matrice identité
   ############################################################################################################################ */

_GLOBAL_ void LoadIdentity(MDFloat *M) {
/* **************************************************************************************************************************** */
	int		 i, j;
/* **************************************************************************************************************************** */
	MDFloat	(*A)[4]	 = (MDFloat (*)[4])M;
/* **************************************************************************************************************************** */
	for (j=0; j<4; j++) 
		for (i=0; i<4; i++)
			if (i == j)
				A[i][j]	 = 1.0;
			else
				A[i][j]	 = 0.0;
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction du produit vectoriel entre deux vecteurs
   ############################################################################################################################ */

void VectProdNorm(MDfloat *u, MDfloat *v, MDfloat *w) {
/******************************************************************************************************************************/
	MDfloat size;
/******************************************************************************************************************************/
	w[0] = u[1]*v[2] - u[2]*v[1];
	w[1] = u[2]*v[0] - u[0]*v[2];
	w[2] = u[0]*v[1] - u[1]*v[0];
/******************************************************************************************************************************/
	size	 = sqrt(ScalProd(w,w));
	if (size == 0) {
		w[0]  = 0;
		w[1]  = 0;
		w[2]  = 0;
		return;
	}
/******************************************************************************************************************************/
	/* normalize */
	w[0] /= size;
	w[1] /= size;
	w[2] /= size;
/******************************************************************************************************************************/
}


/* ############################################################################################################################
   # Fonction de normalisation d'un vecteur
   ############################################################################################################################ */

void Normalize(MDfloat *v) {
/******************************************************************************************************************************/
	MDfloat size	 = sqrt(ScalProd(v,v));
/******************************************************************************************************************************/
	if (size == 0) {
		v[0]  = 0;
		v[1]  = 0;
		v[2]  = 0;
		return;
	}
	/* normalize */
	v[0] /= size;
	v[1] /= size;
	v[2] /= size;
/******************************************************************************************************************************/
}

/* ############################################################################################################################
   # Fonction de multiplication d'une matrice transposée par un vecteur
   ############################################################################################################################ */

void MultMatrixTVec4(MDFloat (*a)[4], MDFloat v[4], MDFloat res[4]) {
/* **************************************************************************************************************************** */
	MDInt	 i,j;
/* **************************************************************************************************************************** */
	for (i=0; i<4; i++) {
		res[i]	 = 0.0;
		for (j=0; j<4; j++) {
			res[i]	+= a[j][i]*v[j];
		}
	}
/* **************************************************************************************************************************** */
}

/* ############################################################################################################################
   # Fonction de multiplication d'une matrice par un vecteur 
   ############################################################################################################################ */

void MultMatrixVec4(MDFloat (*a)[4], MDFloat v[4], MDFloat res[4]) {
/* **************************************************************************************************************************** */
	MDInt	 i,j;
/* **************************************************************************************************************************** */
	// Original matrix is transposed => code below is enough
	for (i=0; i<4; i++) {
		res[i]	 = 0.0;
		for (j=0; j<4; j++) {
			res[i]	+= a[i][j]*v[j];
		}
	}
/* **************************************************************************************************************************** */
}

